---
title: ERa: MACS2 Summary
date: 
bibliography: references.bib
link-citations: true
---


```{r example, echo = FALSE, eval = FALSE}
## This module requires the following to be set during preparation
# target <- "ERa"
# threads <- 6
```

```{r setup}
conda_pre <- system2("echo", "$CONDA_PREFIX", stdout = TRUE)
if (conda_pre != ""){
  conda_lib_path <- file.path(conda_pre, "lib", "R", "library")
  if (!dir.exists(conda_lib_path)) conda_lib_path <- NULL
  prev_paths <- .libPaths()
  paths_to_set <- unique(c(conda_lib_path, prev_paths))
  .libPaths(paths_to_set)
}
knitr::opts_chunk$set(
  message = FALSE, warning = FALSE,
  fig.height = 8, fig.width = 10, fig.align = 'center'
)
```


```{r packages}
library(tidyverse)
library(magrittr)
library(rtracklayer)
library(glue)
library(pander)
library(scales)
library(plyranges)
library(yaml)
library(ngsReports)
library(ComplexUpset)
library(extraChIPs)
```

```{r options}
panderOptions("big.mark", ",")
panderOptions("missing", "")
panderOptions("table.split.table", Inf)
theme_set(
  theme_bw() +
    theme(
      text = element_text(size = 13),
      plot.title = element_text(hjust = 0.5)
    )
)
```

```{r config-paths}
config <- read_yaml(here::here("config", "config.yml"))
macs2_path <- here::here("output", "macs2")
annotation_path <- here::here("output", "annotations")
```

```{r read-samples}
samples <- read_tsv(config$samples) 
samples <- samples[samples$target == target,]
stopifnot(nrow(samples) > 0)
samples$treatment <- as.factor(samples$treatment)
treat_levels <- levels(samples$treatment)
treat_colours <- hcl.colors(max(3, length(treat_levels)), "Zissou 1")[seq_along(treat_levels)]
names(treat_colours) <- treat_levels
accessions <- samples$accession
```


```{r annotations}
sq <- file.path(annotation_path, "chrom.sizes") %>% 
  read_tsv(col_names = c("seqnames", "seqlengths")) %>% 
  mutate(isCircular = FALSE, genome = config$reference$name) %>% 
  as.data.frame() %>% 
  as("Seqinfo") %>% 
  sortSeqlevels()
```


```{r individual-peaks}
individual_peaks <- file.path(
  macs2_path, accessions, glue("{accessions}_peaks.narrowPeak")
) %>%
  importPeaks(seqinfo = sq) %>%
  endoapply(sort) %>% 
  endoapply(names_to_column, var = "accession") %>% 
  endoapply(mutate, accession = str_remove(accession, "_peak_[0-9]+$")) %>% 
  endoapply(
    mutate, 
    treatment = left_join(tibble(accession = accession), samples, by = "accession")$treatment
  ) %>% 
  setNames(accessions)
macs2_logs <- file.path(macs2_path, accessions, glue("{accessions}_callpeak.log")) %>%
  importNgsLogs() %>%
  dplyr::select(
    -contains("file"), -outputs, -n_reads, -alt_fragment_length
  ) %>%
  left_join(samples, by = c("name" = "accession")) %>%
  mutate(
    total_peaks = map_int(
      name,
      function(x) {
        length(individual_peaks[[x]])
      }
    )
  ) 
```

## QC Visualisations {.tabset}

This section provides a simple series of visualisations to aid in the detection of any problematic samples.

- **Library Sizes**: These are the total number of alignments contained in each `bam` file, as passed to `macs2 callpeak` [@Zhang2008-ms]
- **Peaks Detected**: The number of peaks detected within each individual replicate are shown here, and provide clear guidance towards any samples where the IP may have been less successful, or there may be possible sample mis-labelling. 
- **Peaks Per Million Reads**: Whilst no clear benchmark is defined, given the variability of peak distributions across different ChIP targets and treatment, this provides a useful visualisation able to show poorly performing samples next to other samples with the same ChIP target.


```{r macs2-logs-individual}
macs2_logs %>%
  mutate(target = target) %>% 
  dplyr::select(
    sample = name, target, treatment,
    total_peaks, 
    reads = n_tags_treatment, read_length = tag_length,
    fragment_length
  ) %>%
  setNames(
    names(.) %>% str_replace_all("_", " ") %>% str_to_title()
  ) %>%
  pander(
    justify = "lllrrrr",
    caption = glue(
      "*Summary of results for `macs2 callpeak` on individual {target} samples.",
      "Total peaks indicates the number retained after applying the specified FDR ", 
      "threshold during the peak calling process.",
      "The fragment length as estimated by `macs2 predictd` is given in the final column.*",
      .sep = " "
    )
  )
```

### Library Sizes

```{r plot-macs2-libsize-individual, fig.height=6, fig.cap = glue("*Library sizes for each {target} sample. The horizontal line indicates the mean library size for each treatment group. Any samples marked for exclusion as described above will be indicated with an (F)*")}
macs2_logs %>%
  ggplot(
    aes(name, n_tags_treatment)
  ) +
  geom_col(position = "dodge", fill = "royalblue") +
  geom_hline(
    aes(yintercept = mn),
    data = . %>%
      group_by(treatment) %>%
      summarise(mn = mean(n_tags_treatment)),
    linetype = 2,
    col = "grey"
  ) +
  facet_grid(~treatment, scales = "free_x", space = "free_x") +
  scale_y_continuous(expand = expansion(c(0, 0.05)), labels = comma) +
  labs(
    x = "Sample", y = "Library Size"
  ) +
  ggtitle(
    glue("{target}: Library Sizes")
  )
```

### Peaks Detected

```{r plot-macs2-peaks-individual, fig.height=6, fig.cap = glue("*Peaks identified for each {target} sample. The number of peaks passing the inclusion criteria for `macs2 callpeak` (FDR < {config$peaks$macs2$fdr}) are provided. Any samples marked for exclusion are coloured as indicated in the figure legend.*")}
suppressWarnings(
  macs2_logs %>%
    ggplot(
      aes(name, total_peaks)
    ) +
    geom_col(fill = "royalblue") +
    geom_label(
      aes(x = name, y = total_peaks, label = lab),
      data = . %>%
        dplyr::filter(total_peaks > 0) %>% 
        mutate(
          lab = comma(total_peaks, accuracy = 1),
          total = total_peaks
        ),
      inherit.aes = FALSE,
      show.legend = FALSE
    ) +
    facet_grid(~treatment, scales = "free_x", space = "free_x") +
    scale_y_continuous(expand = expansion(c(0, 0.05)), labels = comma) +
    labs(
      x = "Sample",
      y = "Total Peaks",
      fill = "QC"
    ) +
    ggtitle(
      glue("{target}: Number of Peaks")
    )
)
```

### Peaks Per Million Reads

```{r peaks-per-million, fig.cap = "*Peaks per million reads. *"}
macs2_logs %>% 
  mutate(ppm = 1e6 * total_peaks / n_tags_treatment) %>% 
  ggplot(aes(name, ppm)) +
  geom_col(fill = "royalblue") +
  facet_wrap(~treatment) +
  scale_y_continuous(expand = expansion(c(0, 0.05)), labels = comma) +
  labs(x = "Sample", y = "Peaks per Million Reads")
```


## Individual Replicates

A brief summary of all detected peaks for the given target within each replicate is shown using an UpSet plot below.

```{r all-reps-upset, fig.cap = "*UpSet plot showing all samples. Any potential sample/treatment mislabelling will show up clearly here as samples from each group may show a preference to overlap other samples within the same treatment group. Intersections are only included if 10 or more sites are present. The top panel shows a boxplot of the min $q$-values produced by `macs2 callpeak` for each peak in the intersection as representative of the sample with the weakest signal for each peak. The y-axis for this panel is truncated at the 95^th^ percentile of values.*"}
df <- individual_peaks %>%
  makeConsensus(var = "qValue") %>% 
  as_tibble() %>% 
  mutate(qValue = vapply(qValue, min, numeric(1))) 
ql <- samples$accession %>% 
  lapply(
    function(x) upset_query(
      set = x, 
      fill = treat_colours[as.character(dplyr::filter(samples, accession == x)$treatment)]
    )
  )
size <- get_size_mode('exclusive_intersection')
df %>% 
  upset(
    intersect = accessions,
    base_annotations = list(
      `Peaks in Intersection` = intersection_size(
        text_mapping = aes(label = comma(!!size)),
        bar_number_threshold = 1, text_colors = "black", 
        text = list(size = 3, angle = 90, vjust = 0.5, hjust = -0.1)
      ) +
        scale_y_continuous(expand = expansion(c(0, 0.2)), label = comma) +
        theme(
          panel.grid = element_blank(), 
          axis.line = element_line(colour = "grey20"),
          panel.border = element_rect(colour = "grey20", fill =  NA)
        )
    ),
    annotations = list(
      qValue = ggplot(mapping = aes(y = qValue)) +
        geom_boxplot(na.rm = TRUE, outlier.colour = rgb(0, 0, 0, 0.2)) +
        coord_cartesian(ylim = c(0, quantile(df$qValue, 0.95))) +
        scale_y_continuous(expand = expansion(c(0, 0.05))) +
        ylab(expr(paste("Macs2 ", q[min]))) +
        theme(
          panel.grid = element_blank(), 
          axis.line = element_line(colour = "grey20"),
          panel.border = element_rect(colour = "grey20", fill =  NA)
        )
    ),
    set_sizes = (
      upset_set_size() +
        geom_text(
          aes(label = comma(after_stat(count))), 
          hjust = 1.1, stat = 'count', size = 3
        ) +
        scale_y_reverse(expand = expansion(c(0.2, 0)), label = comma) +
        ylab(glue("Macs2 Peaks")) +
        theme(
          panel.grid = element_blank(), 
          axis.line = element_line(colour = "grey20"),
          panel.border = element_rect(colour = "grey20", fill =  NA)
        )
    ),
    queries = ql,
    min_size = 10,
    n_intersections = 50,
    sort_sets = FALSE
  ) +
  theme(
    panel.grid = element_blank(), 
    panel.border = element_rect(colour = "grey20", fill =  NA),
    axis.line = element_line(colour = "grey20")
  ) +
  labs(x = "Intersection") +
  patchwork::plot_layout(heights = c(2, 3, 2))
```

## Merged Replicates {.tabset}

In addition to the above sets of peaks, sets of peaks were called using merged samples within each treatment group.

```{r load-merged-peaks}
merged_peaks <- file.path(
  macs2_path, target, glue("{treat_levels}_merged_peaks.narrowPeak")
) %>% 
  importPeaks(seqinfo = sq) %>% 
  setNames(treat_levels) %>% 
  endoapply(plyranges::remove_names) %>% 
  endoapply(sort)
merged_logs <- file.path(
  macs2_path, target, glue("{treat_levels}_merged_callpeak.log")
) %>%
  importNgsLogs() %>%
  dplyr::select(
    -contains("file"), -outputs, -n_reads, -alt_fragment_length
  ) %>% 
  mutate(
    name = str_remove_all(name, "_merged"),
    total_peaks = map_int(
      name,
      function(x) {
        length(merged_peaks[[x]])
      }
    )
  ) 
```

```{r tbl-merged}
merged_logs %>%
  mutate(target = target) %>% 
  dplyr::select(
    target, treatment = name, 
    total_peaks, 
    reads = n_tags_treatment, read_length = tag_length,
    fragment_length
  ) %>%
  setNames(
    names(.) %>% str_replace_all("_", " ") %>% str_to_title()
  ) %>%
  pander(
    justify = "llrrrr",
    caption = glue(
      "*Summary of results for `macs2 callpeak` on merged {target} samples within treatment groups.",
      "Total peaks indicates the number retained after applying the specified FDR", 
      "threshold during the peak calling process.",
      "The fragment length as estimated by `macs2 predictd` is given in the final column.*",
      .sep = " "
    )
  )
```

### Merged Peaks By Individal Replicate

```{r merged-by-replicate, fig.cap = "*Peaks indentified using merged samples and the overlap with individual samples. Bar heights indicate the total number o peaks identified in each replicate, with the blue segments indicating those also identified when merging replicates.*"}
samples %>% 
  split(.$treatment) %>% 
  lapply(
    function(x) {
      trt <- unique(x$treatment)
      smp <- unique(x$accession)
      ol <- lapply(individual_peaks[smp], overlapsAny, subject = merged_peaks[[trt]])
      tbl <- lapply(ol, function(i) tibble(n = length(i), ol = sum(i), p = mean(i)))
      bind_rows(tbl, .id = "accession")
    }
  ) %>% 
  bind_rows(.id = "treatment") %>% 
  mutate(target = target) %>% 
  ggplot() +
  geom_col(aes(accession, n), fill = "grey70", alpha = 0.7) +
  geom_col(aes(accession, ol), fill = "royalblue") +
  geom_label(
    aes(accession, 0.5 * ol, label = percent(p, 0.1)),
    fill = "white", alpha = 0.7
  ) +
  facet_wrap(~treatment, nrow = 1) +
  scale_y_continuous(expand = expansion(c(0, 0.05)), labels = comma) +
  labs(x = "Sample", y = "Individual Peaks")
```

### Merged Peaks By Number Of Overlaps

```{r merged-by-overlap, fig.cap = "*Treatment-specific peaks called by merging individual replcates are shown by the number of individual replicates they overlap. The percentages peaks with each overlapping number are shown within each bar.*"}
samples %>% 
  split(.$treatment) %>% 
  lapply(
    function(x) {
      trt <- unique(x$treatment)
      acc <- unique(x$accession)
      ol <- lapply(acc, function(i) overlapsAny(merged_peaks[[trt]], individual_peaks[i]))
      names(ol) <- acc
      tbl <- as.matrix(as.data.frame(ol))
      counts <- table(rowSums(tbl))
      tibble(reps = names(counts), total = as.integer(counts))
    }
  ) %>% 
  bind_rows(.id = "treatment") %>% 
  mutate(reps = as.factor(reps)) %>% 
  arrange(desc(reps)) %>% 
  mutate(cumsum = cumsum(total), p = total / sum(total), .by = treatment) %>% 
  mutate(y = cumsum - 0.5 * total) %>% 
  ggplot(aes(treatment, total, fill = reps)) +
  geom_col() +
  geom_label(
    aes(treatment, y, label = percent(p, 0.1)),
    data = . %>% dplyr::filter(p > 0.05),
    fill = "white", alpha = 0.7
  ) +
  scale_y_continuous(expand = expansion(c(0, 0.05)), labels = comma) +
  scale_fill_viridis_d(direction = -1) +
  labs(x = "Treatment", y = "Merged Peaks", fill = "Overlapping\nReplicates")
```

### Merged Peak Overlaps

```{r merged-peak-overlaps, fig.cap = "*Overlap between peaks in each treatment-specific set of peaks called by merging replicates.*"}
plotOverlaps(merged_peaks, set_col = treat_colours)
```


## References

<div id="refs"></div>

<br>
<button type="button" class="btn btn-default btn-sessioninfo" data-toggle="collapse" data-target="#sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span> Session information
</button>
</p>
<div id="sessioninfo" class="collapse">
```{r session-info, echo=FALSE}
pander::pander(sessionInfo())
```
</div>
